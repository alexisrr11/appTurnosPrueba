El proceso correcto es:

Paso 1 â€” ValidaciÃ³n bÃ¡sica

Verificar que nombre, email y password existan

Validar formato email

Validar longitud mÃ­nima password

Paso 2 â€” Verificar duplicado

Buscar en DB si ya existe ese email

Si existe â†’ devolver error

Paso 3 â€” Hashear contraseÃ±a

Nunca guardar password plano

Usar bcrypt

Generar hash seguro

Paso 4 â€” Guardar usuario

Insertar en tabla usuarios

Guardar hash

Paso 5 â€” Respuesta

Devolver datos pÃºblicos (id, nombre, email)

Nunca devolver password

Eso es registro seguro.

ğŸ” 4ï¸âƒ£ Flujo completo de LOGIN (conceptual)

Cuando el cliente hace:

POST /login


El proceso correcto:

Paso 1 â€” ValidaciÃ³n bÃ¡sica

Email y password obligatorios

Paso 2 â€” Buscar usuario

Buscar por email

Si no existe â†’ error genÃ©rico (no revelar cuÃ¡l campo fallÃ³)

Paso 3 â€” Comparar contraseÃ±a

Usar bcrypt.compare

Comparar password enviada con hash guardado

Paso 4 â€” Si coincide

TenÃ©s dos opciones:

OpciÃ³n bÃ¡sica (sin JWT por ahora)

Devolver mensaje "Login exitoso"

Devolver datos usuario

No hay sesiÃ³n real

OpciÃ³n profesional (recomendada)

Generar JWT

Enviar token al frontend

Frontend lo guarda

Se manda en headers Authorization

Eso permite proteger rutas.

ğŸ”’ 5ï¸âƒ£ CÃ³mo proteger turnos

Una vez que tengas login, el flujo correcto serÃ­a:

Usuario hace login

Recibe token

Cada request a:

POST /turnos

GET /turnos

DELETE /turnos

PUT /turnos

debe enviar el token

El backend:

Verifica token

Extrae usuario_id

Solo muestra turnos de ese usuario

Eso convierte tu app en sistema multiusuario real.

ğŸ§  6ï¸âƒ£ Flujo interno de request protegido

Cuando llega una request protegida:

1ï¸âƒ£ Leer header Authorization
2ï¸âƒ£ Verificar JWT
3ï¸âƒ£ Extraer user id
4ï¸âƒ£ Adjuntarlo al request
5ï¸âƒ£ Continuar hacia el controlador

Eso se hace con middleware.

ğŸš€ 7ï¸âƒ£ QuÃ© vas a "desestructurar" despuÃ©s

Ahora estÃ¡s sin arquitectura.

Cuando refactorices vas a separar:

routes/

controllers/

middlewares/

services/

database/

utils/

Eso es arquitectura limpia.

Pero primero estÃ¡ perfecto hacerlo todo en un solo archivo para entender el flujo completo.

ğŸ¯ Orden recomendado para que no te rompas nada

1ï¸âƒ£ Crear tabla usuarios
2ï¸âƒ£ Probar registro
3ï¸âƒ£ Probar login
4ï¸âƒ£ Agregar usuario_id a turnos
5ï¸âƒ£ Proteger rutas
6ï¸âƒ£ Refactorizar

ğŸ¯ 1ï¸âƒ£ Â¿QuÃ© es turnos?

Es un recurso REST.

Por lo tanto tu base va a ser:

/turnos

ğŸš€ 2ï¸âƒ£ MÃ©todos y rutas que deberÃ­as tener
âœ… 1. Crear turno

MÃ©todo: POST
Ruta: /turnos

Se usa para:

Registrar un nuevo turno

Validar que no exista otro en la misma fecha y hora

Validar datos obligatorios

âœ… 2. Obtener todos los turnos

MÃ©todo: GET
Ruta: /turnos

Sirve para:

Listar todos los turnos

ordenar por fecha y hora

filtros por fecha

Ejemplos futuros que podrÃ­as agregar:

/turnos?fecha=2026-02-20
/turnos?cliente=Juan

âœ… 3. Obtener un turno por ID

MÃ©todo: GET
Ruta: /turnos/:id

Validaciones:

ID numÃ©rico

Que exista el turno

âœ… 4. Actualizar un turno

MÃ©todo: PUT (reemplazo completo)
o
PATCH (actualizaciÃ³n parcial)

Ruta: /turnos/:id

Sirve para:

Cambiar fecha

Cambiar hora

Cambiar cliente

Cambiar servicio

âš ï¸ Importante:
Si se cambia fecha u hora â†’ se debe volver a validar el UNIQUE.

âœ… 5. Eliminar un turno

MÃ©todo: DELETE
Ruta: /turnos/:id

Sirve para:

Cancelar turno

ğŸ§  3ï¸âƒ£ Opcional (nivel mÃ¡s profesional)

Si querÃ©s subir nivel despuÃ©s:

ğŸ” Ver disponibilidad

GET /turnos/disponibles?fecha=2026-02-20

Para:

Mostrar horarios libres

Calcular horas posibles y eliminar las ocupadas

ğŸ“… Ver turnos de un cliente

GET /turnos?cliente=Alexis